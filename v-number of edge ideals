--first package in Macaulay2. It includes a function for the computation of v-number. 
--this compute the v-number (see https://www.sciencedirect.com/science/article/pii/S0196885819301241?via%3Dihub, proposition 4.2)


newPackage( 
         "Vnumber",
         Version => "1.0",
         Date => "April 24, 2020",
         Authors => {{Name => "Rafael Villarreal",
                      Email => "vila@math.cinvestav.mx",
                      HomePage => "www.math.cinvestav.mx/~vila"
                      },    
                     {Name => "Delio Jaramillo-Velez",
                     Email => djaramillo@math.cinvestav.mx}
                    },
         Headline => "A package for the computation of Vnumber", DebuggingMode => true
         )
         export{"Vnumber"}
         -- this file contents a function that compute the Vnumber of a ideal
         -- this is a joint work with Rafael Villarreal
 
 --------------------------------------------------------------
 --================= v-number function ========================
 
 fun_gen = method();
 fun_gen (Ideal,ZZ) := (I,n) -> (
 L:=ass I;
 flatten flatten degrees mingens(quotient(I,L#n)/I)
 )
 
-- pp_grobner = method();
-- pp_grobner (Ideal,ZZ) := (I,n) -> (
-- L:=ass I;
-- gens gb ideal(flatten mingens(quotient(I,L#n)/I))
 --)
 
 gg_fun = method();
 gg_fun (List) := (a) -> (
 toList(set a-set{0}) 
 )
 
 vnumber = method();
  vnumber (Ideal) := (I) ->
    (
      L:=ass I;     
      N:=apply(apply(0..#L-1,i->fun_gen(I,i)),i->gg_fun(i));
      min flatten N 
    )
    
    
    
    
    
    
 -----------------------------------------------------------
 --****************** Footprint Function ********************
 
 mset_func = method();
 mset_func (Ideal,Ideal) := (I,x) -> (
 if not quotient(ideal(leadTerm gens gb I),x)==ideal(leadTerm gens gb I) then 
    degree coker gens gb ideal(ideal(leadTerm gens gb I),x) 
 else 0 
 )
 
 maxdegree = method();
 maxdegree (ZZ,ZZ,Ideal) := (d,r,I) -> (
 max apply(apply(apply(subsets(flatten entries basis(d,coker gens gb I),r),toSequence),ideal),i->mset_func(I,i))
 )
 
 footPrint = method();
 footPrint (ZZ,ZZ,Ideal) := (d,r,I) ->(
 degree coker gens gb I - maxdegree(d,r,I)
 )
    
    
 
-----------------------------------------------------------
 --****************** GMD Function ********************
 
 elem = method();
 elem (ZZ,ZZ,ZZ,Ideal) := (q,d,I) ->(
 apply(toList (set(0..q-1))^**(hilbertFunction(d,coker gens gb I))-(set{0})^**(hilbertFunction(d,coker gens gb I)),toList)
 )
 
 elemBas = method();
 elemBas (ZZ,ZZ,Ideal) := (q,d,I) ->(
 apply(elem(q,d,I),x -> basis(d,coker gens gb I)*vector deepSplice x)
 )
 
 setBas = method();
 setBas (ZZ,ZZ,ZZ,Ideal) := (q,d,r,I) ->(
 subsets(apply(elemBas(q,d,I),z->ideal(flatten entries z)),r)
 )
 
 --------------------------------------------------------
 -=====================hyp function======================
 
 hYpFunction = method();
 hypFunction (ZZ,ZZ,ZZ,Ideal) := (q,d,r,I) ->(
 max apply(
 apply(
 setBas(q,d,r,I),ideal),
 x -> if #set flatten entries mingens ideal(leadTerm gens x)==r and not quotient(I,x)==I
         then degree(I+x)
      else 0
)
 )
 
 --------------------------------------------------------
 
 gMdFunction = method();
 gMdFunction (ZZ,ZZ,ZZ,Ideal) := (q,d,r,I) ->(
 degree(coker gens gb I)-hYp(q,d,r,I)
 )
 
 
 
 
 --------------------------------------------------------------
 --===================== Vasconcelos Function ================
 
 
 vasFunction = method();
 vasFunction (ZZ,ZZ,ZZ,Ideal) := (q,d,r,I) ->(
 min apply(
 apply(
 setBas(q,d,r,I),ideal),
 x -> if #set flatten entries mingens ideal(leadTerm gens x)==r and not quotient(I,x)==I
         then degree(coker gens gb quotient(I,x)
      else degree(coker gens gb I)
)
 )
 
 
-----------------------------------------------------------
--====================WEIGHT MATRIX===========================


---------------------------------------------------------------
--===================footprint matrix==========================



----------The incidence matrix code of a Graph G-------
loadPackage "Graphs"
loadPackage "NAGtypes"

--These are two procedure for obtain an incidence matrix code of a Graph G
-- be sure that p is a prime number 

--1-- this procedure computes all the points in the code. It computes all the linear forms.
--inputs: an GRaph and a prime number 
-- outputs: a sequences with all the points in the code

codeGrahpInc = method(TypicalValue => Sequence);
codeGrahpInc(Graph,ZZ):= (G,p)->(
tInc:=transpose incidenceMatrix G;
X:=entries tInc;
R:=ZZ/p[t_(0)..t_(lentgh vertexSet G-1)];
Poly1:=apply(apply(toList (set(0..p-1))^**(hilbertFunction(1,R))-(set{0})^**(hilbertFunction(1,R)),toList),x -> basis(1,R)*vector deepSplice x);
Polynums1:=apply(0..length Poly1-1, x->polySystem{Poly1#x#0})
XX=apply(X,x->point{x})
apply(Polynums1,y->apply(0..length XX -1,x->(flatten entries evaluate(y,XX#x))#0))
)



--2-- this procedure computes the generatrix matrix of the code---
-- M is the incidence matrix of the Graph G

codeGrahpIncM = method(TypicalValue => Module);
codeGrahpIncM (Matrix,ZZ):= (M,p)->(
tInc:=transpose M;
X:=entries tInc;
R:=ZZ/p[t_(0)..t_(numgens target M-1)];
SetPol:=flatten entries basis(1,R);
SetPolSys:=apply(0..length SetPol-1, x->polySystem{SetPol#x});
XX:=apply(X,x->point{x});
C:=apply(apply(SetPolSys,y->apply(0..length XX -1,x->(flatten entries evaluate(y,XX#x))#0)),toList);
image transpose matrix{C}
)



        
    
-------------------------------------------------------------  
--====================== Documentation =========================  
    
 beginDocumentation()
  doc ///
    Key
        Vnumber
    Headline
        This Package computes the vnumber of an ideal 
    Description
        Text
            I will add more functions in coding theory.
    
  
  
  
  
 ----------------------------------------------------- 
--***************** Tests ****************************
    
    
    

end







